import {
    AfterViewInit,
    Component,
    ElementRef,
    Input,
    OnChanges,
    OnInit,
    Output,
    SimpleChanges,
    ViewChild
} from '@angular/core';
import {timer} from 'rxjs/internal/observable/timer';

export class PolygonGraphData {
    safe: boolean;
    title: string;
    titleStyle: string;
    colorStyle: string;
}

    // templateUrl: './polygon.component.html',
    // styleUrls: ['./polygon.component.scss']
    // template: '<canvas #canvas></canvas>'
    // 1.0.3
@Component({
    selector: 'graphk-gaugeStep',
    template: '<canvas #canvas></canvas>',
    styles: ['canvas {border: 1px solid black}']
})

export class GaugeStepComponent implements OnInit, AfterViewInit, OnChanges {
    @Input()
    public width: number;
    @Input()
    public height: number;
    @Input()
    public padding = 5;
    @Input()
    public angleRadian = Math.PI;
    @Input()
    public data: PolygonGraphData;

    @Output()
    @ViewChild('canvas') public canvasElementRef: ElementRef;

    constructor() {
    }

    ngOnChanges(changes: SimpleChanges) {
        this.reDraw();
    }
    ngOnInit() {
        this.reDraw();
    }

    ngAfterViewInit() {
        this.reDraw();
    }

    private reDraw() {
        // console.log(event.target);
        const canvas = this.canvasElementRef.nativeElement as HTMLCanvasElement;
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // if (!this.data || !this.data.data || this.data.data.length < 3) {
        //     return;
        // }

        // console.log(this.canvasContainerElementRef.nativeElement.clientWidth);
        // return;
        // canvas.height = canvas.width = Math.max(this.canvasContainerElementRef.nativeElement.clientWidth - 5, 0);
        canvas.width = Math.max(this.width - 5, 0)
        canvas.height = Math.max(this.height - 5, 0)
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        // const startAngle = -Math.PI / 2;
        // const sides = this.data.data.length;
        const radius = (centerX) - this.padding;
        // const jumpRadius = (radius) / this.polygonLength;

        // timer()
        // timer(1000).subscribe(() => {
        //     this.drawArc();
        // });
        // true : 반시계
        // false: 시방향 default
        // ctx.arc(canvas.width / 2, canvas.height / 2, radius, 0, this.angleRadian, true);
        // const end = this.angleRadian / 2 - 0.4;
        // const end = this.angleRadian;
        // const end = Math.PI * 2 - 0.5;
        const end = Math.PI;
        const r = Math.PI * 2 - end;
        // ctx.arc(canvas.width / 2, canvas.height / 2, radius, Math.PI - end, end, true);
        ctx.save(); // 드로잉 상태를 저정한다.
        ctx.translate(centerX, centerY);
        // 90도 돌리고 남은 각에 절반만큼 더 돌린다.
        ctx.rotate((Math.PI / 2) + r / 2);
        // ctx.rotate((Math.PI / 2));
        // ctx.rotate(Math.PI);
        // ctx.rotate(Math.PI - Math.PI - end);
        // ctx.rotate(Math.PI + Math.PI - end);
        // ctx.rotate(Math.PI);
        ctx.beginPath();
        ctx.arc(0, 0, radius, 0, end);
        ctx.stroke();
        ctx.restore(); // 기존 드로잉 상태를 복구한다.
        // ctx.beginPath(); //경로 그리기 시작
        // ctx.moveTo(canvas.width / 2, canvas.height / 2); //기준 좌표값 이동
        // context.translate(x, y);
        // ctx.lineTo(100,100); // X, Y 좌표를 사용하여 선 그리기
        // ctx.lineTo(200,100); // X, Y 좌표를 사용하여 선 그리기
        // ctx.fill(); //경로 그리기 종료(채움)
        // ctx.beginPath(); //경로 그리기 시작
        // ctx.moveTo(50, 50); //기준 좌표값 이동
        // ctx.lineTo(200,50); // X, Y 좌표를 사용하여 선 그리기
        // ctx.lineTo(50,200);
        // ctx.fill(); //경로 그리기 종료(채움)
    }

    public drawArc() {
        alert(1);
        // const canvas = this.canvasElementRef.nativeElement as HTMLCanvasElement;
        // const ctx = canvas.getContext('2d');
        // const radius = (centerX) - this.padding;
        // ctx.beginPath();
        // // ctx.arc(canvas.width / 2, canvas.height / 2, radius, 0, this.angleRadian, true);
        // // const end = this.angleRadian / 2 - 0.4;
        // const end = this.angleRadian;
        // ctx.arc(canvas.width / 2, canvas.height / 2, radius, Math.PI - end, end, true);
        // ctx.stroke();
    }
}
